// ============================================================================
// WICHTIG: Manuelle Migrationen!
// ============================================================================
// Dieses Projekt verwendet Supabase mit pgBouncer (Connection Pooling).
// Daher werden Migrationen NICHT automatisch mit `prisma migrate dev` erstellt,
// sondern manuell:
//
// 1. Schema hier anpassen
// 2. Migration SQL-Datei manuell erstellen unter:
//    prisma/migrations/YYYYMMDDHHMMSS_beschreibung/migration.sql
// 3. Migration deployen mit: npx prisma migrate deploy
// 4. Prisma Client neu generieren: npx prisma generate
//
// Siehe auch: https://www.prisma.io/docs/guides/deployment/deploy-database-changes-with-prisma-migrate
// ============================================================================

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [uuid_ossp(map: "uuid-ossp", schema: "extensions")]
}

model User {
  id                      String                  @id @default(cuid())
  email                   String?                 @unique
  name                    String?
  password                String
  role                    Role                    @default(CUSTOMER)
  clientId                String?
  createdAt               DateTime                @default(now())
  updatedAt               DateTime                @updatedAt
  active                  Boolean                 @default(true)
  color                   String?
  categories              AgentCategory[]
  fullName                String?
  roleTitle               String?
  favoriteClients         FavoriteClient[]
  feedbacks               Feedback[]              @relation("FeedbackAuthor")
  noticesCreated          Notice[]                @relation("NoticesCreated")
  customerNoticesCreated  CustomerNotice[]        @relation("CustomerNoticesCreated")
  noticeAcknowledgements  NoticeAcknowledgement[]
  noticeAssignments       NoticeRecipient[]
  projects                Project[]               @relation("AgentProjects")
  filmProjectsCutting     ProjectFilm[]           @relation("FilmProjectCutter")
  filmProjectsResponsible ProjectFilm[]           @relation("FilmProjectFilmer")
  notesAuthored           ProjectNote[]           @relation("NoteAuthor")
  client                  Client?                 @relation(fields: [clientId], references: [id])
  preferences             UserPreferences?

  @@index([clientId])
}

model UserPreferences {
  id                           String   @id @default(cuid())
  userId                       String   @unique
  createdAt                    DateTime @default(now())
  updatedAt                    DateTime @updatedAt
  filmProjectsAgentFilter      Json?
  filmProjectsPStatusFilter    Json?
  filmProjectsScopeFilter      Json?
  filmProjectsStatusFilter     Json?
  projectsAgentFilter          Json?
  projectsCmsFilter            Json?
  projectsPriorityFilter       Json?
  projectsStatusFilter         Json?
  printDesignAgentFilter       Json?
  printDesignStatusFilter      Json?
  printDesignProjectTypeFilter Json?
  user                         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Client {
  id                  String               @id @default(cuid())
  name                String
  phone               String?
  notes               String?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  customerNo          String?              @unique
  serverId            String?
  finished            Boolean              @default(false)
  workStopped         Boolean              @default(false)
  agencyId            String?
  email               String?
  firstname           String?
  lastname            String?
  salutation          String?
  uploadLinks         Json?
  ftpPasswords        Json?
  // Kundenportal-Felder
  portalEnabled       Boolean              @default(false)
  portalPasswordHash  String?
  portalLastLogin     DateTime?
  portalInvitedAt     DateTime?
  // LuckyCloud-Zuordnung
  luckyCloudLibraryId   String?            // Seafile Library-ID
  luckyCloudLibraryName String?            // Library-Name (zur Anzeige)
  luckyCloudFolderPath  String?            // Ordnerpfad innerhalb der Library
  authorizedPersons   AuthorizedPerson[]
  agency              Agency?              @relation(fields: [agencyId], references: [id])
  server              Server?              @relation("ClientToServer", fields: [serverId], references: [id])
  clientServers       ClientServer[]
  contract            ClientContract?
  customerNotices     CustomerNoticeRecipient[]
  emailLogs           EmailLog[]
  favoritedBy         FavoriteClient[]
  joomlaInstallations JoomlaInstallation[]
  projects            Project[]
  users               User[]

  @@index([name])
  @@index([agencyId])
  @@index([serverId])
}

model Agency {
  id              String           @id @default(cuid())
  name            String
  contactName     String?
  contactEmail    String?
  contactPhone    String?
  street          String?
  postalCode      String?
  city            String?
  country         String?
  website         String?
  notes           String?
  logoPath        String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  logoIconPath    String?
  clients         Client[]
  emailSignatures EmailSignature[]
  mailServers     MailServer[]
  customerNotices CustomerNotice[]
}

model Project {
  id                  String               @id @default(cuid())
  title               String?
  type                ProjectType          @default(WEBSITE)
  status              ProjectStatus        @default(WEBTERMIN)
  important           String?
  clientId            String
  agentId             String?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  emailLogs           EmailLog[]
  emailQueue          EmailQueue[]
  joomlaInstallations JoomlaInstallation[]
  agent               User?                @relation("AgentProjects", fields: [agentId], references: [id])
  client              Client               @relation(fields: [clientId], references: [id])
  film                ProjectFilm?
  notes               ProjectNote[]
  website             ProjectWebsite?
  printDesign         ProjectPrintDesign?

  @@index([clientId, status])
  @@index([agentId])
}

model ProjectWebsite {
  projectId        String                 @id
  domain           String?
  priority         WebsitePriority        @default(NONE)
  pStatus          ProductionStatus       @default(NONE)
  cms              CMS                    @default(JOOMLA)
  cmsOther         String?
  webDate          DateTime?
  demoDate         DateTime?
  onlineDate       DateTime?
  lastMaterialAt   DateTime?
  effortBuildMin   Int?
  effortDemoMin    Int?
  seo              SEOStatus?
  textit           TextitStatus?
  accessible       Boolean?
  note             String?
  demoLink         String?
  materialStatus   MaterialStatus         @default(ANGEFORDERT)
  isWTAssignment   Boolean                @default(false)
  webterminType    WebterminType?
  isRelaunch       Boolean                @default(false)
  // LuckyCloud Material-Ordner (Unterordner im Kunden-Ordner)
  luckyCloudFolderPath  String?           // Relativer Pfad zum Material-Ordner (z.B. "/Inhalte")
  domainHistory    ProjectDomainHistory[]
  project          Project                @relation(fields: [projectId], references: [id])
  webDocumentation WebDocumentation?
}

// Webdokumentation - Sammlung aller relevanten Informationen für die Webseitenerstellung
// Aufbau in 7 Schritten: 1. Allgemeines, 2. Unternehmensschwerpunkte, 3. Websiteaufbau,
// 4. Design & Vorgaben, 5. Formulare, 6. Impressum & Datenschutz, 7. Material
model WebDocumentation {
  projectId          String                      @id

  // ===== Schritt 1: Allgemeines =====
  contactEmail       String?                     // E-Mail-Adresse (vorbelegt aus Client)
  urgentNotes        String?                     // Dringend zu beachten (Textarea)
  websiteDomain      String?                     // Domain für die Website
  domainStatus       WebDocuDomainStatus?        // Status: neu, vorhanden, schon bei EM/VW

  // ===== Schritt 2: Unternehmensschwerpunkte =====
  companyName        String?                     // Name des Unternehmens
  companyFocus       String?                     // Unternehmensschwerpunkte (Textarea)

  // ===== Schritt 3: Websiteaufbau =====
  // Menüpunkte werden in separater Tabelle gespeichert
  menuItems          WebDocuMenuItem[]

  // ===== Schritt 4: Design & Vorgaben =====
  // Bereich Design
  hasLogo            Boolean?                    // Logo vorhanden ja/nein
  hasCIDefined       Boolean?                    // CI definiert ja/nein
  colorOrientation   WebDocuColorOrientation?    // Farborientierung
  colorCodes         String?                     // Farben/Farbcodes (Freitext)

  // Bereich Umsetzungsvorgaben
  topWebsite         String?                     // Top-Webseite (Referenz)
  flopWebsite        String?                     // Flop-Webseite (Referenz)
  websiteType        WebDocuWebsiteType?         // Art der Webseite
  styleTypes         String[]                    // Stile der Webseite (Mehrfachauswahl)
  styleCustom        String?                     // Individueller Stil (wenn CUSTOM in styleTypes)
  startArea          WebDocuStartArea?           // Startbereich
  slogan             String?                     // Slogan
  teaserSpecs        String?                     // Teaservorgaben
  disruptorSpecs     String?                     // Störervorgaben
  otherSpecs         String?                     // Sonstige Vorgaben (RichText)
  mapIntegration     WebDocuMapIntegration?      // Map-Einbindung

  // ===== Schritt 5: Formulare =====
  noFormsRequired    Boolean                     @default(false) // Kein Formular gewünscht
  forms              WebDocuForm[]

  // ===== Schritt 6: Impressum & Datenschutz =====
  imprintFromWebsite Boolean?                    // Von aktueller Webseite übernehmen
  imprintAddress     String?                     // Anschrift
  imprintLegalForm   String?                     // Geschäftsform
  imprintOwner       String?                     // Inhaber
  imprintCeo         String?                     // Geschäftsführer
  imprintPhone       String?                     // Telefonnummer
  imprintFax         String?                     // Faxnummer
  imprintEmail       String?                     // E-Mail-Adresse
  imprintRegisterType WebDocuRegisterType?       // Registerart
  imprintRegisterCustom String?                  // Freies Textfeld für Registerart
  imprintRegisterLocation String?                // Registerort
  imprintRegisterNumber String?                  // Registernummer
  imprintChamber     String?                     // Kammer
  imprintProfession  String?                     // Berufsbezeichnung
  imprintCountry     String?                     // Staat
  imprintVatId       String?                     // Umsatzsteuer-ID (DE...)
  imprintTermsStatus WebDocuTermsStatus?         // AGB Status
  imprintPrivacyOfficer String?                  // Datenschutzbeauftragter (Name)
  imprintHasPrivacyOfficer Boolean?              // Haben Sie einen Datenschutzbeauftragten benannt?

  // ===== Schritt 7: Material =====
  materialLogoNeeded       Boolean?                // Logo nachzureichend (nur wenn hasLogo=true in Step 4)
  materialAuthcodeNeeded   Boolean?                // Authcode nachzureichend (nur wenn domainStatus=EXISTS_TRANSFER)
  materialNotes            String?                 // Weitere Infos / Anmerkungen (allgemeines Material)
  materialNotesNeedsImages Boolean?                // Allgemeines Material: Bilder benötigt
  materialNotesNeedsTexts  Boolean?                // Allgemeines Material: Texte/Stichpunkte benötigt
  materialDeadline         DateTime?               // Frist für Materialeinsendung

  // Bilder-Status für Logo (vom Kunden als vollständig markiert)
  logoImagesSubmittedAt    DateTime?               // Zeitpunkt der Markierung "Logo vollständig"
  logoImagesSubmittedByName String?                // Name des Kunden der markiert hat
  // Bilder-Status für Logo (vom Agenten geprüft)
  logoImagesReviewedAt     DateTime?               // Zeitpunkt der Prüfung durch Agenten
  logoImagesReviewedById   String?                 // ID des Agenten der geprüft hat
  logoImagesReviewedByName String?                 // Name des Agenten
  logoImagesComplete       Boolean?                // Vom Agenten als vollständig markiert
  logoImagesAgentComment   String?                 // Kommentar/Hinweis des Agenten an den Kunden
  // Bilder-Status für Sonstiges/Allgemeines Material (vom Kunden als vollständig markiert)
  generalImagesSubmittedAt DateTime?               // Zeitpunkt der Markierung "Sonstige Bilder vollständig"
  generalImagesSubmittedByName String?             // Name des Kunden der markiert hat
  // Bilder-Status für Sonstiges/Allgemeines (vom Agenten geprüft)
  generalImagesReviewedAt     DateTime?            // Zeitpunkt der Prüfung durch Agenten
  generalImagesReviewedById   String?              // ID des Agenten der geprüft hat
  generalImagesReviewedByName String?              // Name des Agenten
  generalImagesComplete       Boolean?             // Vom Agenten als vollständig markiert
  generalImagesAgentComment   String?              // Kommentar/Hinweis des Agenten an den Kunden

  // Vom Kunden eingereichte Texte für allgemeines Material
  generalTextSubmission    MaterialGeneralSubmission?

  // ===== Kundenfreigabe =====
  releasedAt             DateTime?               // Zeitpunkt der Freigabe für den Kunden
  releasedByUserId       String?                 // User-ID des Freigebenden
  releasedByName         String?                 // Name des Freigebenden (für Anzeige)

  // ===== Kundenbestätigung =====
  confirmedAt            DateTime?               // Zeitpunkt der Bestätigung durch den Kunden
  confirmedByPersonId    String?                 // ID der AuthorizedPerson die bestätigt hat
  confirmedByName        String?                 // Name der Person (für Anzeige)
  confirmedByIp          String?                 // IP-Adresse des Kunden bei Bestätigung

  // ===== Interner Vermerk (für Agenten) =====
  internalNote           String?                 // Interner Vermerk für spätere Verwendung

  createdAt          DateTime                    @default(now())
  updatedAt          DateTime                    @updatedAt
  project            ProjectWebsite              @relation(fields: [projectId], references: [projectId], onDelete: Cascade)

  // Ansprechpartner für diese Webdoku (Verknüpfung zu AuthorizedPerson)
  contacts           WebDocumentationContact[]

  // Kundenfeedback (optional, nur wenn mit Anpassungswünschen bestätigt)
  feedback           WebDocuFeedback?
}

// Kundenfeedback zur Webdokumentation
// Wird erstellt wenn Kunde "Mit Anpassungswünschen bestätigen" wählt
model WebDocuFeedback {
  id                     String            @id @default(cuid())
  webDocumentationId     String            @unique  // Nur ein Feedback pro Webdoku

  // Feedback-Bereiche (alle optional - Kunde wählt was er kommentieren will)
  generalComment         String?           // Allgemeines Feedback
  focusComment           String?           // Kommentar zu Schwerpunkten (Schritt 2)
  structureComment       String?           // Kommentar zu Websiteaufbau/Menüs (Schritt 3)
  designComment          String?           // Kommentar zu Designwünschen (Schritt 4)
  formsComment           String?           // Kommentar zu Formularen (Schritt 5)

  // Status-Tracking durch Agent ("wird beachtet")
  focusAcknowledged      Boolean           @default(false)
  structureAcknowledged  Boolean           @default(false)
  designAcknowledged     Boolean           @default(false)
  formsAcknowledged      Boolean           @default(false)

  createdAt              DateTime          @default(now())
  createdByName          String?           // Name des Kunden der das Feedback gegeben hat

  webDocumentation       WebDocumentation  @relation(fields: [webDocumentationId], references: [projectId], onDelete: Cascade)
}

// Formular für Webdokumentation (Schritt 5)
// Jede Webdokumentation kann mehrere Formulare haben (z.B. Kontaktformular, Bewerbungsformular)
model WebDocuForm {
  id                   String                @id @default(cuid())
  webDocumentationId   String
  name                 String                // Name/Zweck des Formulars (z.B. "Kontaktformular", "Bewerbung")
  recipientEmail       String?               // Empfänger-E-Mail-Adresse
  sortOrder            Int                   @default(0)
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt

  webDocumentation     WebDocumentation      @relation(fields: [webDocumentationId], references: [projectId], onDelete: Cascade)
  fields               WebDocuFormField[]

  @@index([webDocumentationId])
}

// Formularfelder für ein Formular
model WebDocuFormField {
  id                   String                @id @default(cuid())
  formId               String
  fieldType            WebDocuFormFieldType  // Art des Feldes
  label                String?               // Optionales Label für benutzerdefinierte Felder
  isRequired           Boolean               @default(false)
  sortOrder            Int                   @default(0)
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt

  form                 WebDocuForm           @relation(fields: [formId], references: [id], onDelete: Cascade)

  @@index([formId])
}

// Formularfeld-Typen (Standard-Felder + Custom)
enum WebDocuFormFieldType {
  // Standard-Felder
  ANREDE               // Anrede
  VORNAME              // Vorname
  NACHNAME             // Nachname
  EMAIL                // E-Mail
  TELEFON              // Telefon
  STRASSE              // Straße
  PLZ                  // PLZ
  ORT                  // Ort
  NACHRICHT            // Nachricht/Textarea
  DATENSCHUTZ          // Datenschutz-Checkbox
  // Benutzerdefinierte Felder
  CUSTOM_TEXT          // Benutzerdefiniertes Textfeld
  CUSTOM_TEXTAREA      // Benutzerdefiniertes Textarea
  CUSTOM_CHECKBOX      // Benutzerdefinierte Checkbox
  CUSTOM_SELECT        // Benutzerdefiniertes Dropdown
}

// Menüpunkte für Websiteaufbau (Schritt 3)
model WebDocuMenuItem {
  id                   String            @id @default(cuid())
  webDocumentationId   String
  name                 String            // Name des Menüpunkts
  parentId             String?           // Null = Hauptmenüpunkt, sonst ID des Elternelements
  sortOrder            Int               // Reihenfolge innerhalb der Ebene
  isFooterMenu         Boolean           @default(false) // Gehört zum Footer-Menü
  notes                String?           // Hinweise/Notizen zum Menüpunkt (Step 3)
  // Schritt 7: Material - Nachzureichendes Material pro Menüpunkt
  needsImages          Boolean           @default(false) // Bilder nachzureichend
  needsTexts           Boolean           @default(false) // Texte/Stichpunkte nachzureichend
  materialNotes        String?           // Konkrete Material-Hinweise (z.B. welche Bilder/Texte benötigt werden)
  // Bilder-Status (vom Kunden als vollständig markiert)
  imagesSubmittedAt    DateTime?         // Zeitpunkt der Markierung als "Bilder vollständig"
  imagesSubmittedByName String?          // Name des Kunden der markiert hat
  // Bilder-Status (vom Agenten geprüft)
  imagesReviewedAt     DateTime?         // Zeitpunkt der Prüfung durch Agenten
  imagesReviewedById   String?           // ID des Agenten der geprüft hat
  imagesReviewedByName String?           // Name des Agenten
  imagesComplete       Boolean           @default(false) // Vom Agenten als vollständig markiert
  imagesAgentComment   String?           // Kommentar/Hinweis des Agenten an den Kunden
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt

  webDocumentation     WebDocumentation  @relation(fields: [webDocumentationId], references: [projectId], onDelete: Cascade)
  parent               WebDocuMenuItem?  @relation("MenuItemHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children             WebDocuMenuItem[] @relation("MenuItemHierarchy")
  textSubmission       MaterialTextSubmission? // Vom Kunden eingereichte Texte

  @@index([webDocumentationId])
  @@index([parentId])
}

// Vom Kunden eingereichte Texte/Stichpunkte pro Menüpunkt
model MaterialTextSubmission {
  id                 String          @id @default(cuid())
  menuItemId         String          @unique // Nur eine Text-Einreichung pro Menüpunkt
  content            String          // Der eingereichte Text (RichText/HTML)
  submittedAt        DateTime?       // Zeitpunkt der finalen Einreichung (null = noch nicht eingereicht)
  submittedByName    String?         // Name des Kunden der eingereicht hat
  isResubmission     Boolean         @default(false) // true = wurde nach Ablehnung erneut eingereicht
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt

  // Bewertung durch Agent/Admin
  reviewedAt         DateTime?       // Zeitpunkt der Bewertung (null = noch nicht bewertet)
  reviewedBy         String?         // User-ID des Bewerters
  reviewedByName     String?         // Name des Bewerters
  suitable           Boolean?        // true = geeignet, false = ungeeignet, null = nicht bewertet
  reviewNote         String?         // Hinweis bei Ablehnung (warum ungeeignet)
  previousReviewNote String?         // Vorheriger Ablehnungsgrund (bei erneuter Einreichung zur Dokumentation)

  menuItem           WebDocuMenuItem @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
}

// Vom Kunden eingereichte Texte für allgemeines Material (Weitere Hinweise/Anmerkungen)
model MaterialGeneralSubmission {
  id                   String           @id @default(cuid())
  webDocumentationId   String           @unique // Nur eine allgemeine Text-Einreichung pro Webdoku
  content              String           // Der eingereichte Text (RichText/HTML)
  submittedAt          DateTime?        // Zeitpunkt der finalen Einreichung (null = noch nicht eingereicht)
  submittedByName      String?          // Name des Kunden der eingereicht hat
  isResubmission       Boolean          @default(false) // true = wurde nach Ablehnung erneut eingereicht
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  // Bewertung durch Agent/Admin
  reviewedAt           DateTime?        // Zeitpunkt der Bewertung (null = noch nicht bewertet)
  reviewedBy           String?          // User-ID des Bewerters
  reviewedByName       String?          // Name des Bewerters
  suitable             Boolean?         // true = geeignet, false = ungeeignet, null = nicht bewertet
  reviewNote           String?          // Hinweis bei Ablehnung (warum ungeeignet)
  previousReviewNote   String?          // Vorheriger Ablehnungsgrund (bei erneuter Einreichung zur Dokumentation)

  webDocumentation     WebDocumentation @relation(fields: [webDocumentationId], references: [projectId], onDelete: Cascade)
}

// Verknüpfungstabelle für Ansprechpartner in der Webdokumentation
model WebDocumentationContact {
  id                   String            @id @default(cuid())
  webDocumentationId   String
  authorizedPersonId   String
  isPrimary            Boolean           @default(false) // Hauptansprechpartner
  createdAt            DateTime          @default(now())
  webDocumentation     WebDocumentation  @relation(fields: [webDocumentationId], references: [projectId], onDelete: Cascade)
  authorizedPerson     AuthorizedPerson  @relation(fields: [authorizedPersonId], references: [id], onDelete: Cascade)

  @@unique([webDocumentationId, authorizedPersonId])
  @@index([webDocumentationId])
  @@index([authorizedPersonId])
}

// Domain-Status für Webdokumentation
enum WebDocuDomainStatus {
  NEW              // Neue Domain (muss registriert werden)
  EXISTS_STAYS     // Vorhanden (Domain bleibt bei Kunden)
  EXISTS_TRANSFER  // Vorhanden (Domain wird zu EM/VW transferiert)
  AT_AGENCY        // Schon bei EM/VW (bereits bei der Agentur)
}

// Farborientierung für Schritt 4
enum WebDocuColorOrientation {
  LOGO             // Am Logo orientiert
  PRINT            // Am Printprodukt orientiert
  CI_SHEET         // Am CI-Bogen orientiert
  WEBSITE          // An bestehender Webseite orientiert
}

// Art der Webseite für Schritt 4
enum WebDocuWebsiteType {
  STANDARD         // Standard-Webseite mit mehreren Seiten
  ONEPAGE          // Onepage-Webseite
}

// Startbereich für Schritt 4
enum WebDocuStartArea {
  HEADER_VIDEO     // Header-Video
  SLIDER           // Slider
  HEADER_IMAGE     // Header-Bild
}

// Map-Einbindung für Schritt 4
enum WebDocuMapIntegration {
  YES              // Ja, eine Map
  MULTIPLE         // Ja, mehrere Standorte
  NO               // Nein, keine Map
}

// Registerart für Schritt 6 (Impressum)
enum WebDocuRegisterType {
  HANDELSREGISTER  // Handelsregister
  CUSTOM           // Anderes (freies Textfeld)
}

// AGB-Status für Schritt 6 (Impressum)
enum WebDocuTermsStatus {
  AVAILABLE        // AGB vorhanden
  NOT_AVAILABLE    // AGB nicht vorhanden
  NOT_NECESSARY    // AGB nicht notwendig
}

model ProjectDomainHistory {
  id         String         @id @default(cuid())
  projectId  String
  domain     String
  assignedAt DateTime       @default(now())
  removedAt  DateTime?
  reason     String?
  createdAt  DateTime       @default(now())
  project    ProjectWebsite @relation(fields: [projectId], references: [projectId])

  @@index([projectId])
  @@index([domain])
}

model ProjectFilm {
  projectId        String               @id
  scope            FilmScope?
  priority         FilmPriority         @default(NONE)
  filmerId         String?
  cutterId         String?
  contractStart    DateTime?
  scouting         DateTime?
  scriptToClient   DateTime?
  scriptApproved   DateTime?
  shootDate        DateTime?
  firstCutToClient DateTime?
  finalToClient    DateTime?
  onlineDate       DateTime?
  lastContact      DateTime?
  status           FilmProjectStatus    @default(AKTIV)
  reminderAt       DateTime?
  note             String?
  finalLink        String?
  onlineLink       String?
  previewVersions  FilmPreviewVersion[]
  cutter           User?                @relation("FilmProjectCutter", fields: [cutterId], references: [id])
  filmer           User?                @relation("FilmProjectFilmer", fields: [filmerId], references: [id])
  project          Project              @relation(fields: [projectId], references: [id])

  @@index([status])
  @@index([filmerId])
  @@index([cutterId])
  @@index([reminderAt])
}

model FilmPreviewVersion {
  id        String      @id @default(cuid())
  projectId String
  version   Int
  sentDate  DateTime
  createdAt DateTime    @default(now())
  link      String      @default("")
  project   ProjectFilm @relation(fields: [projectId], references: [projectId], onDelete: Cascade)

  @@unique([projectId, version])
  @@index([projectId, sentDate])
}

model ProjectPrintDesign {
  projectId              String                @id
  projectType            PrintDesignType?
  pStatus                ProductionStatus      @default(NONE)
  webtermin              DateTime?
  implementation         DateTime?
  designToClient         DateTime?
  designApproval         DateTime?
  finalVersionToClient   DateTime?
  printRequired          Boolean               @default(false)
  printOrderPlaced       DateTime?
  printProvider          String?
  note                   String?
  project                Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
}

model ProjectNote {
  id        String   @id @default(cuid())
  projectId String
  authorId  String
  text      String
  createdAt DateTime @default(now())
  author    User     @relation("NoteAuthor", fields: [authorId], references: [id])
  project   Project  @relation(fields: [projectId], references: [id])

  @@index([projectId, createdAt])
}

model Server {
  id                  String               @id @default(cuid())
  name                String
  ip                  String
  froxlorUrl          String?
  mysqlUrl            String?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  froxlorApiKey       String?
  froxlorApiSecret    String?
  hostname            String?
  sshHost             String?
  sshPassword         String?
  sshPort             Int?                 @default(22)
  sshUsername         String?
  froxlorVersion      String?              @default("2.0+")
  clients             Client[]             @relation("ClientToServer")
  clientServers       ClientServer[]
  databaseServers     DatabaseServer[]
  joomlaInstallations JoomlaInstallation[]
}

model DatabaseServer {
  id                  String               @id @default(cuid())
  serverId            String
  name                String
  version             String
  host                String               @default("localhost")
  port                Int?                 @default(3306)
  isDefault           Boolean              @default(false)
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  froxlorDbServerId   Int?
  server              Server               @relation(fields: [serverId], references: [id], onDelete: Cascade)
  joomlaInstallations JoomlaInstallation[]

  @@index([serverId])
}

model MailServer {
  id         String       @id @default(cuid())
  name       String
  host       String
  port       Int          @default(587)
  username   String?
  password   String?
  fromEmail  String
  fromName   String?
  useTls     Boolean      @default(true)
  notes      String?
  agencyId   String?
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  emailLogs  EmailLog[]
  emailQueue EmailQueue[]
  agency     Agency?      @relation(fields: [agencyId], references: [id])

  @@index([agencyId])
  @@index([name])
}

model EmailTemplate {
  id        String                @id @default(cuid())
  title     String                @unique
  subject   String
  body      String
  createdAt DateTime              @default(now())
  updatedAt DateTime              @updatedAt
  category  EmailTemplateCategory @default(GENERAL)
  triggers  EmailTrigger[]

  @@index([createdAt])
  @@index([category])
}

model EmailSignature {
  key       String   @id
  body      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  agencyId  String?
  agency    Agency?  @relation(fields: [agencyId], references: [id])
}

model EmailTrigger {
  id              String           @id @default(cuid())
  name            String
  description     String?
  active          Boolean          @default(true)
  triggerType     EmailTriggerType
  projectType     ProjectType?
  conditions      Json
  delayDays       Int?
  delayType       DelayType?
  templateId      String
  recipientConfig Json
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  sentLogs        EmailLog[]
  queuedEmails    EmailQueue[]
  template        EmailTemplate    @relation(fields: [templateId], references: [id])

  @@index([active, triggerType])
  @@index([templateId])
}

model EmailQueue {
  id           String       @id @default(cuid())
  triggerId    String
  projectId    String
  scheduledFor DateTime
  status       QueueStatus  @default(PENDING)
  toEmail      String
  ccEmails     String?
  subject      String
  body         String
  mailServerId String?
  attempts     Int          @default(0)
  lastAttempt  DateTime?
  sentAt       DateTime?
  error        String?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  mailServer   MailServer?  @relation(fields: [mailServerId], references: [id])
  project      Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  trigger      EmailTrigger @relation(fields: [triggerId], references: [id], onDelete: Cascade)

  @@index([status, scheduledFor])
  @@index([projectId])
  @@index([triggerId])
}

model EmailLog {
  id           String        @id @default(cuid())
  triggerId    String?
  projectId    String?
  toEmail      String
  ccEmails     String?
  subject      String
  body         String
  sentAt       DateTime      @default(now())
  success      Boolean       @default(true)
  error        String?
  mailServerId String?
  clientId     String?
  client       Client?       @relation(fields: [clientId], references: [id])
  mailServer   MailServer?   @relation(fields: [mailServerId], references: [id])
  project      Project?      @relation(fields: [projectId], references: [id])
  trigger      EmailTrigger? @relation(fields: [triggerId], references: [id])

  @@index([sentAt])
  @@index([projectId])
  @@index([triggerId])
  @@index([clientId])
}

model Notice {
  id                     String                  @id @default(cuid())
  title                  String
  message                String
  visibility             NoticeVisibility        @default(GLOBAL)
  requireAcknowledgement Boolean                 @default(false)
  isActive               Boolean                 @default(true)
  createdById            String
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  createdBy              User                    @relation("NoticesCreated", fields: [createdById], references: [id], onDelete: Cascade)
  acknowledgements       NoticeAcknowledgement[]
  recipients             NoticeRecipient[]

  @@index([isActive, visibility])
  @@index([createdById])
}

model NoticeRecipient {
  noticeId   String
  userId     String
  assignedAt DateTime @default(now())
  notice     Notice   @relation(fields: [noticeId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([noticeId, userId])
  @@index([userId])
}

model NoticeAcknowledgement {
  id       String   @id @default(cuid())
  noticeId String
  userId   String
  readAt   DateTime @default(now())
  notice   Notice   @relation(fields: [noticeId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([noticeId, userId])
  @@index([userId])
}

// Kundenportal-Hinweise (separate von Agenten-Hinweisen)
model CustomerNotice {
  id              String                     @id @default(cuid())
  title           String
  message         String
  targetGroup     CustomerNoticeTargetGroup  @default(ALL_CUSTOMERS)
  agencyId        String?                    // Falls AGENCY_CUSTOMERS: welche Agentur
  showOnDashboard Boolean                    @default(false) // Wichtige Hinweise auch auf Dashboard anzeigen
  isActive        Boolean                    @default(true)
  createdById     String
  createdAt       DateTime                   @default(now())
  updatedAt       DateTime                   @updatedAt
  createdBy       User                       @relation("CustomerNoticesCreated", fields: [createdById], references: [id], onDelete: Cascade)
  agency          Agency?                    @relation(fields: [agencyId], references: [id], onDelete: SetNull)
  recipients      CustomerNoticeRecipient[]

  @@index([isActive, targetGroup])
  @@index([isActive, showOnDashboard])
  @@index([createdById])
  @@index([agencyId])
}

// Für SELECTED_CUSTOMERS: welche Kunden sind Empfänger
model CustomerNoticeRecipient {
  noticeId   String
  clientId   String
  assignedAt DateTime       @default(now())
  notice     CustomerNotice @relation(fields: [noticeId], references: [id], onDelete: Cascade)
  client     Client         @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@id([noticeId, clientId])
  @@index([clientId])
}

enum CustomerNoticeTargetGroup {
  ALL_CUSTOMERS       // Alle Kunden
  AGENCY_CUSTOMERS    // Kunden einer bestimmten Agentur (EM oder VW)
  SELECTED_CUSTOMERS  // Ausgewählte Kunden
}

model Feedback {
  id             String         @id @default(cuid())
  title          String
  message        String
  type           FeedbackType   @default(SUGGESTION)
  status         FeedbackStatus @default(OPEN)
  authorId       String
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  viewedByAuthor Boolean        @default(false)
  adminResponse  String?
  author         User           @relation("FeedbackAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  @@index([status, createdAt])
  @@index([authorId])
  @@index([authorId, viewedByAuthor])
}

model JoomlaInstallation {
  id                         String          @id @default(cuid())
  clientId                   String
  serverId                   String
  customerNo                 String
  folderName                 String
  installPath                String
  installUrl                 String
  databaseName               String
  databasePassword           String
  standardDomain             String
  filesExtracted             Int?
  bytesProcessed             BigInt?
  createdAt                  DateTime        @default(now())
  updatedAt                  DateTime        @updatedAt
  projectId                  String?
  projectAssignmentDismissed Boolean         @default(false)
  databaseServerId           String?
  databaseHost               String?
  databasePort               Int?
  client                     Client          @relation(fields: [clientId], references: [id], onDelete: Cascade)
  databaseServer             DatabaseServer? @relation(fields: [databaseServerId], references: [id])
  project                    Project?        @relation(fields: [projectId], references: [id])
  server                     Server          @relation(fields: [serverId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([serverId])
  @@index([projectId])
  @@index([customerNo])
  @@index([createdAt])
  @@index([projectAssignmentDismissed])
  @@index([databaseServerId])
}

model FavoriteClient {
  id        String   @id @default(cuid())
  userId    String
  clientId  String
  createdAt DateTime @default(now())
  client    Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, clientId])
  @@index([userId])
  @@index([clientId])
}

model AuthorizedPerson {
  id                String                      @id @default(cuid())
  clientId          String
  salutation        String?
  firstname         String
  lastname          String
  email             String
  position          String?
  phone             String?
  notes             String?
  createdAt         DateTime                    @default(now())
  updatedAt         DateTime                    @default(now()) @updatedAt
  client            Client                      @relation(fields: [clientId], references: [id], onDelete: Cascade)
  webDocumentations WebDocumentationContact[]

  @@index([clientId])
}

model ClientServer {
  id         String   @id @default(cuid())
  clientId   String
  serverId   String
  customerNo String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  client     Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  server     Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)

  @@unique([clientId, serverId])
  @@index([clientId])
  @@index([serverId])
  @@index([customerNo])
}

model ClientContract {
  id                  String              @id @default(cuid())
  clientId            String              @unique
  // Vertragsdaten
  contractStart       DateTime?           // Vertragsbeginn
  contractDuration    Int?                // Laufzeit in Monaten
  setupFee            Decimal?            @db.Decimal(10, 2) // Setup in Euro
  paymentInterval     PaymentInterval?    // Zahlweise
  paymentMethod       PaymentMethod?      // Zahlart (SEPA, Rechnung, Sonstige)
  monthlyAmount       Decimal?            @db.Decimal(10, 2) // monatlicher Betrag
  // Leistungsumfang (als Array von Enums)
  services            ContractService[]
  // Adressdaten
  street              String?
  houseNumber         String?
  postalCode          String?
  city                String?
  // Kontaktdaten
  phone1              String?
  phone2              String?
  mobile              String?
  // Weitere Felder
  note                String?             // Notiz
  minTermEnd          DateTime?           // Ende Mindestlaufzeit
  cancellation        String?             // Storno/Kündigung (Freitext)
  sepaMandate         String?             // SEPA-Mandat
  createdBy           String?             // Schreiber (User-ID oder Name)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  // Relation
  client              Client              @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([contractStart])
  @@index([minTermEnd])
}

enum EmailTemplateCategory {
  GENERAL
  WEBSITE
  FILM
  SOCIAL_MEDIA
  PRINT_DESIGN
}

enum Role {
  ADMIN
  AGENT
  CUSTOMER
  SALES
}

enum ProjectType {
  WEBSITE
  FILM
  SOCIAL
  PRINT_DESIGN
}

enum ProjectStatus {
  WEBTERMIN
  MATERIAL
  UMSETZUNG
  DEMO
  ONLINE
  BEENDET
}

enum WebsitePriority {
  NONE
  PRIO_1
  PRIO_2
  PRIO_3
}

enum FilmScope {
  FILM
  DROHNE
  NACHDREH
  FILM_UND_DROHNE
  FOTO
  GRAD_360
  K_A
}

enum FilmPriority {
  NONE
  FILM_SOLO
  PRIO_1
  PRIO_2
}

enum FilmProjectStatus {
  AKTIV
  BEENDET
  WARTEN
  VERZICHT
  MMW
}

enum CMS {
  SHOPWARE
  WORDPRESS
  JOOMLA
  CUSTOM
  OTHER
}

enum ProductionStatus {
  NONE
  BEENDET
  MMW
  VOLLST_A_K
  VOLLST_K_E_S
}

enum SEOStatus {
  NEIN
  NEIN_NEIN
  JA_NEIN
  JA_JA
  JA
}

enum TextitStatus {
  NEIN
  NEIN_NEIN
  JA_NEIN
  JA_JA
  JA
}

enum MaterialStatus {
  ANGEFORDERT
  TEILWEISE
  VOLLSTAENDIG
  NV
}

enum WebterminType {
  TELEFONISCH
  BEIM_KUNDEN
  IN_DER_AGENTUR
  OHNE_TERMIN
}

enum PrintDesignType {
  LOGO
  VISITENKARTE
  FLYER
  PLAKAT
  BROSCHÜRE
  SONSTIGES
}

enum AgentCategory {
  WEBSEITE
  FILM
  SOCIALMEDIA
  PRINT_DESIGN
}

enum EmailTriggerType {
  DATE_FIELD_SET
  DATE_REACHED
  CONDITION_MET
  MANUAL
}

enum DelayType {
  BEFORE
  AFTER
  EXACT
}

enum QueueStatus {
  PENDING
  SENDING
  SENT
  FAILED
  CANCELLED
  PENDING_CONFIRMATION
}

enum NoticeVisibility {
  GLOBAL
  TARGETED
}

enum FeedbackType {
  BUG
  SUGGESTION
  IMPROVEMENT
  OTHER
}

enum FeedbackStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  DISMISSED
}

enum PaymentInterval {
  MONTHLY       // monatlich
  QUARTERLY     // vierteljährlich
  SEMI_ANNUAL   // halbjährlich
  ANNUAL        // jährlich
}

enum PaymentMethod {
  SEPA          // SEPA-Lastschrift
  INVOICE       // Rechnung
  OTHER         // Sonstige
}

enum ContractService {
  WEBSITE_SUCCESS     // Webseite (Success)
  WEBSITE_HOSTING     // Webseitenhosting
  TEXTERSTELLUNG      // Texterstellung (Textit)
  FILM_IMAGE          // Film (Image)
  FILM_HOSTING        // Filmhosting
  SEO_PLUS            // SEOplus
  BARRIEREFREIHEIT    // Barrierefreiheit (B-free)
  DROHNE_ONAIR        // Drohne (onAir)
  FOTOERSTELLUNG      // Fotoerstellung
  ONLINESHOP_SHOPIT   // Onlineshop (Shopit)
  FULL_CONTENT        // Full Content
  SECURE_PLUS         // SecurePlus
  ADWORDS_ADLEIT      // Adwords (Adleit)
  SOCIAL_MEDIA        // Social-Media
}
